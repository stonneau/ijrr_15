% !TEX root =  ../main.tex
\section{From a guide path to a discrete sequence of contact configurations ($\mathcal{P}_2$)}
\label{sec:contact}
In the second phase, we compute a discrete sequence of static equilibrium configurations $\mathbf{Q}^{\overline{0}}$ given a root path
$\mathbf{q}^0(t) : [0,1] \longrightarrow$ \gls{$C_{Reach}^0$}. This contact planner is built on top of
a contact generator, used to generate static equilibrium configurations. We first describe the generator, before detailing the contact planning algorithm.
%~ Our planner computes guide paths in $C_{Reach}^0$ , an approximation of \gls{$C_{Equil}^0$}.
%~ As an input of this stage, we however assume an \gls{equilibrium feasible} root guide path $\mathbf{q}^0(t) : [0,1] \longrightarrow$ \gls{$C_{Equil}^0$}.
%~ If this is not the case, our planner will fail rapidly, thus allowing replanning, as discussed in Section~\ref{sec:perf}.
%~ We now consider the second problem of computing a discrete sequence of equilibrium configurations $\mathbf{Q}^{\overline{0}}$ along $\mathbf{q}^0(t)$.


%~ In this Section we first describe a single contact-generation process, that is how to generate a contact configuration for a limb, given a
%~ root location.
%~ Then, we propose an iterative algorithm to generate a discrete sequence of contact configurations in static equilibrium.

%~ Our criterion to assert efficiently the static equilibrium of the system
%~ is described in Appendix~\ref{sec:heuristics}.

\subsection{Definition of a contact sequence}
In previous contributions, a contact plan is defined as a sequence of configurations that describe a quasi-static equilibrium configuration
for each existing phase of the motion. For instance, a walk cycle would be described by three key configurations: a double support configuration,
a simple configuration (the contact is broken), and another double support configuration (a contact is created). Our definition of the contact plan differs: in this example it would simply consists in the two double support configurations. 
However, in the case where the contact broken and the contact created sequentially are not related to the same effector, our planner outputs two distinct states.
This representation is sufficient to describe all the contact constraints of the problem. Furthermore it removes the unnecessary constraint of having a simple support,
quasi static configuration in the path as in the example. As shown in the validation video, this allows our framework to produce motions that are not quasi static, but dynamic. 

\subsection{Contact generator}
\label{sec:single_contact}

\begin{figure*}
  \centering
  \begin{overpic}[width=0.8\linewidth]{figures/contact_gen}
		\put (1,1) {a} 
		\put (22,1) {b} 
		\put (42,1) {c} 
		\put (62,1) {d} 
		\put (83,1) {e} 
	\end{overpic}
  \caption{Generation of a contact configuration for the right leg of HRP-2. (a): Selection of reachable obstacles. (b): Entries of the limb samples database (with $N = 4$). (c): With a proximity query between the octree database and the obstacles, configurations too far from obstacles are discarded. (d): The best candidate according to a user-defined heuristic $h$ is chosen. (e): The final contact is achieved using inverse kinematics.}
  \label{fig:contact_gen}
\end{figure*}


The contact generation treats each limb $R^k$ independently.
Given a configuration of the root and the other limbs, it computes a configuration $\mathbf{q}^k$ such that $R^k$ is in contact and the robot $R$ is in static equilibrium:
\begin{equation}
\label{eq:contact_gen}
	\mathbf{q}^{\overline{k}}  \longrightarrow \mathbf{q}^k, (\mathbf{q}^{k} \oplus \mathbf{q}^{\overline{k}}) \in  C_{Equil} \wedge \mathbf{q}^k \in  C_{Contact}^k 
\end{equation}

Contact generation is typically adressed by randomly sampling a limb configuration, before projecting the effector onto the closest surface with an inverse kinematics solver.
This process is repeated until either a solution for Eq.~(\ref{eq:contact_gen}) is found, or the generator fails, according to a user-defined maximum number of trials.
We favor a modified implementation of this naive approach, more computationally efficient, introduced in our previous work~\citep{Tonneau2014}.

%~ Given a configuration $\mathbf{q}^{\overline{k}}$ of the root and all the limbs but $R^k$, we look for a limb configuration $\mathbf{q}^k$ such that
%~ $R^k$ is in contact, and not colliding (neither with parts of the robot nor with the environment).
%~ While exhibiting analytically a $\mathbf{q}^{k}$ does not seem tractable, we can iteratively try to generate one as follows:
%~ \begin{enumerate}
%~ \item Generate randomly a collision-free limb configuration;
%~ \item Project the end-effector onto the closest surface with inverse kinematics;
%~ \item If a valid solution is found, stop. Otherwise repeat from step 1.
%~ \end{enumerate}


%~ We favor a modified implementation of this naive approach, more computationally efficient, introduced in our previous work~\citep{Tonneau2014}.

We define $C_{Contact}^{\epsilon} \supset C_{Contact}$ as the set of configurations such that the minimum distance 
between an effector and an obstacle is less than $\epsilon \in \mathbb{R}$.
We then apply the following steps:
\begin{enumerate}
\item Generate off-line $N$ valid sample limb configurations $\mathbf{q}^k_i,  0 \leq i < N$;
\item Using the end-effector positions $\mathbf{p}(\mathbf{q}^k_i)$ as indices, store each sample in an octree data structure;
\item At runtime, when contact creation is required, intersect the octree and the environment to retrieve the list of samples $S \subset C_{Contact}^{\epsilon}$ close to contact (Figure~\ref{fig:contact_gen} (b) and (c));
\item Use a user-defined heuristic $h$ to sort $S$;
\item If $S$ is empty, stop (failure). Else select the first configuration of $S$. Project it onto contact using inverse kinematics. (Figure~\ref{fig:contact_gen} (d) and (e));
\item If Eq.~\ref{eq:contact_gen} is verified, stop (success). Otherwise remove the element from $S$ and go to step 5.
\end{enumerate}

%~ This approach has two main advantages.
%~ First, this allows us to select a large number of candidates in a single proximity request.
%~ Having several candidates is interesting, because it allows to compare them using a user-selected heuristic $h$, thus obtaining
%~ a locally-optimal candidate.
%~ Furthermore, the fact that the candidates are already close to contact increases the odds that the inverse kinematics will converge to a valid solution in a small number of iterations.
%~ Regarding convergence, it is immediate to verify that as $N$ grows, the probability of finding a solution if it exists converges to 1.
%~ $N$ is a parameter that allows us to specify the trade-off between exhaustiveness and efficiency.
The reader is invited to refer to our previous work for an extensive discussion on the benefits of this approach, and the optimal choice 
of the parameter $N$~\citep{Tonneau2014}. Our criterion to assert efficiently the static equilibrium of the robot, as well as the heuristics $h$ are detailed in Appendix~\ref{sec:heuristics}.

%~ It should be noted that a failure case for our contact generator does not necessarily mean that the planner will globally fail. Indeed,
%~ for a given root configuration, if contact configurations are found for other limbs, resulting in static equilibrium, the configuration will be accepted despite
%~ the failure to generate a contact.

\subsection{Contact planning algorithm}
Starting from an initial whole-body configuration, we use the contact generator to compute a sequence
of whole-body configurations  $\mathbf{Q}^{\overline{0}}$ along the root path $\mathbf{q}^0(t)$.
The algorithm details can be found in Appendix~\ref{app:contact}. Here we provide an intuition of it.
%~ Although we address acyclic contact sequences, the algorithm is deterministic in the order in which 
%~ the contacts are created, allowing it to break the combinatorial.

First, the root path $\mathbf{q}^0(t)$ is discretized into a sequence of $j$ key configurations:  
\begin{equation*}
	\mathbf{Q}^0 = [\mathbf{q}^0_{0}; \mathbf{q}^0_{i}; ..., \mathbf{q}^0_{j-1}]
\end{equation*} 
where $\mathbf{q}^0_{0}$ and $\mathbf{q}^0_{j-1}$ are the start and goal configurations. %To ensure continuity in the contact transition phases,
Each root configuration of $\mathbf{Q}^0$ is then extended into a whole-body configuration such that:
\begin{itemize} 
\item At most one contact is not maintained (\textit{broken}) between two consecutive configurations.
\item At most one contact is added between two consecutive configurations.
\item Each configuration is in static equilibrium.
\item Each configuration is collision-free.
\end{itemize} 


%~ We want to extend the configurations of $\mathbf{Q}^0$ in such a way that continuity is preserved regarding the contact transitions.
%~ To do so, we define an algorithm that, given the current root configuration, and the previous full body configuration, computes a full body configuration 
%~ in $C_{Equil}$ such that contacts are maintained if possible.
%~ The first full body configuration of the sequence is given by the initial state of the robot.

 %~ we propose a recursive mapping $\pi$, for any $0<i<j$:
%~ \begin{equation*}
    %~ \pi\colon\left\{
    %~ \begin{aligned}		
        %~ \mathbf{Q}^0 \in C_{Equil}^0 & \longrightarrow C_{Equil} \\
        %~ %\mathbf{q}^{0}_0 &  \longrightarrow  \mathbf{q}_{start} \\
        %~ \mathbf{q}^{0}_i &  \longrightarrow  g(\mathbf{q}_{i - 1},\mathbf{q}^{0}_i) 
    %~ \end{aligned}
    %~ \right.
%~ \end{equation*} 
%~ $g$ is the method that extends a root configuration into a full-body configuration. At each step, it tries to generate a contact configuration that preserves as much as possible
%~ the previous contacts while allowing for static equilibrium. The objective is thus to characterize $g$.
%~ We initialize the recurrence with $\pi(\mathbf{q}^0_{0}) = \mathbf{q}_0$ the initial configuration of the robot.

%~ The function $g$ is defined independently by $g^k$ for each limb $R^k$. In defining $g^k$, two aspects must be considered. Is the limb $R^k$ in contact? And which criteria is it optimizing? 

\subsubsection{Maintaining a contact in the sequence:}

%~ Figure~\ref{fig:break_contact} illustrates the contact-persistence strategy.
If kinematically possible, a limb in contact at step $i-1$ remains in contact at step $i$ (Figure~\ref{fig:break_contact}). 
%~ The contact is broken if an inverse-kinematics solver fails to find a collision-free limb configuration that satisfies joint limits. 
%~ The solver is directly provided by the HPP software.
Otherwise the contact is broken and a collision-free configuration is assigned to the limb.
If two or more contacts can't be maintained between two consecutive configurations, one or more intermediate configurations are added, to ensure
that at most one contact is broken between two sequential configurations.
%~ For these steps the root configuration is the same as for the previous step, with the difference that
%~ one faulty contact is repositioned, in the hope that it will not be broken at the next step.

\begin{figure}[t]
\centering
  \begin{overpic}[width=0.9\linewidth]{figures/break_contact}
		\put (0,4) {1} 
		\put (25,4) {2} 
		\put (50,4) {3} 
		\put (76,4) {4} 
		%~ \put (68,58) {3.a)} 
		%~ \put (5,27) {3.b)} 
		%~ \put (37,27) {4.a)} 
		%~ \put (68,27) {4.b)} 
	\end{overpic}
\caption{Contacts are maintained if joint limits and collisions constraints are respected (2). They are broken otherwise(3,4). The green line represents the root path.}
		   \label{fig:break_contact}
\end{figure}

%~ \begin{figure}[t]
%~ \centering
  %~ \begin{overpic}[width=0.6\linewidth]{figures/generate_contact}
		%~ \put (5,58) {1)} 
		%~ \put (37,58) {2)} 
		%~ \put (68,58) {3.a)} 
		%~ \put (5,27) {3.b)} 
		%~ \put (37,27) {4.a)} 
		%~ \put (68,27) {4.b)} 
	%~ \end{overpic}
%~ \caption{Contacts are generated when the configuration is not balanced.}
		   %~ \label{fig:generate_contact}
%~ \end{figure}

%\subsection{Generation of a contact configuration}  
\subsubsection{Creating contacts:}
Contacts are created using a FIFO approach: we try first to create a contact with the limb that has been contact-free the longest. If the contact creation does not succeeds, the limb is pushed on top of the queue, and will only be tried again after the others.
%~ \begin{enumerate}
%~ \item \deladp{At most one contact creation happens between two consecutive steps. }
%~ \item \deladp{A contact is validated if and only if the resulting configuration is in static equilibrium;}
%~ \item \deladp{We use a FIFO approach:  we always try first to create a contact with the limb that has been contact-free the longest. If the contact creation
%~ was not successful for a limb, the limb is pushed on top of the queue, and will only be tried again after the others.}
%~ \end{enumerate}

This set of rules defines a deterministic contact planning algorithm.
The determinism of this algorithm makes it efficient, at the cost of not being probabilistically complete.
%~ \deladp{However, in practice the planner is successful in the large majority of cases, as discussed in Section~\ref{sec:perf}.}
