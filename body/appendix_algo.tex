% !TEX root =  ../main_tro.tex
\subsubsection{Pseudo-code of the Algorithm}
\label{app:contact}


%~ First, we define an abstract structure State,
%~ that describes a contact configuration.
%~ The use of queues allows a FIFO approach regarding the order 
%~ in which contacts are tested: we try to replace older contacts first when necessary.
%~ Thus the algorithm is deterministic even though it can handle acyclic motions. \\
%~ 
%~ \begin{lstlisting}]
%~ Struct Limb
%~ {
    %~ // Limb Configuration
    %~ Configuration qk;
    %~ // Effector position in
    %~ // world coordinates
    %~ vector6 pk;
%~ };
%~ 
%~ Struct State
%~ {
    %~ // root location
    %~ Configuration q0;
    %~ // List of limbs not in contact
    %~ queue<Limb> freeLimbs;
    %~ // List of limbs in contact
    %~ queue<Limb> contactLimbs;
%~ };
%~ \end{lstlisting}

From the start configuration, given as an input by the user,
we create the initial state $s0$.
Algorithm~\ref{alg:interpolate}  is then called with $s0$, as well as the discretized path 
$\mathbf{Q}^0$, as input parameters.

\begin{algorithm}[!tbp]
\caption{Discretization of a path} \label{interpolate}
	\begin{algorithmic}[1]
	%~ \Function{GenerateConfiguration}{}
	\Function{Interpolate}{$s0$,$\mathbf{Q}^0$, $MAX\_TRIES$}
		\State $states \gets (s0)$ \Comment{List of states intialized with $s0$}
		\State $nb\_fail \gets 0$ 
		\State $i \gets 1;$ \Comment{Current index in the list}
		\While {$i < length(\mathbf{Q}^0)$}
			\State $pState \gets last\_element(states)$
			\State $s \gets$ \textsc{GenFullBody}$(pState, element(\mathbf{Q}^0,i))$
			\If {$s \not= 0 $}
				\State $nb\_fail \gets 0$
				\State $i \gets i+1$
				\State \textbf{return} $\mathbf{q}^{0}$
			\Else
				\State $nb\_fail \gets nb\_fail + 1$
				\If {$nb\_fail == MAX\_TRIES$}
					\State \textbf{return} $FAILURE$
				\EndIf				
				\State $s \gets $\textsc{IntermediateContactState}$(pState)$
			\EndIf
			\State $push_back(states, s)$
		\EndWhile
		\State \textbf{return} $states$
	\EndFunction
\end{algorithmic}
\label{alg:interpolate}
\end{algorithm}

At each step, \textsc{GenFullBody} is called with the previous state as a parameter, as well
as a new root configuration. \textsc{GenFullBody} returns a new contact configuration, if it succeeded
in computing a configuration with only one contact switch occurring.
Otherwise, the method \textsc{IntermediateContactState} is called.
It repositions one end effector (either a free limb, or the oldest active contact) towards a new contact position if possible.
This repositioning allows to increase the odds that the contact can be maintained at the next step.
The method \textit{last\_element} returns the last element
of the list, \textit{element} returns the element contained by a list at a given index, and \textit{push\_back} inserts an element at the end of a list.
Algorithm~\ref{alg:pi} gives the pseudo code for \textsc{GenFullBody}.

\begin{algorithm}[!tbp]
\caption{Full body contact generation method} \label{interpolate}
	\begin{algorithmic}[1]
	%~ \Function{GenerateConfiguration}{}
	\Function{\textsc{GenFullBody}}{$pState$,$\mathbf{q}^0$}
		\State State $newState$
		\State $newState.q0 = \mathbf{q}^0$
		\State $newState.freeLimbs = pState.freeLimbs$
		\State /*First try to maintain previous contacts*/
		\State $nbContactsBroken = 0$
		\For {\textbf{each} Limb $k$ in $pState.contactLimbs$}
			\If {$!$\textsc{MaintainContact}$(pState,\mathbf{q}^0,k)$}
				\State $nbContactsBroken += 1$
				\If {$nbContactsBroken > 1$}				
					\State \textbf{return} $NULL$
				\EndIf				
				\State $push(newState.freeLimbs,k)$
			\Else 					
				\State $push(newState.contactLimbs,k)$
			\EndIf
		\EndFor
		\For {\textbf{each} Limb $k$ in $pState.freeLimbs$}
			\If {\textsc{GenerateContact}$(\mathbf{q}^0,k)$}	
				\State $push(newState.contactLimbs,k)$
				\State $remove(newState.freeLimbs,k)$		
				\State \textbf{return} $newState$
			\EndIf
		\EndFor
		\If {\textsc{IsInStaticEquilibrium}$(newState)$}
			\State \textbf{return} $newState$
		\Else
			\State \textbf{return} $NULL$
		\EndIf
	\EndFunction
\end{algorithmic}
\label{alg:pi}
\end{algorithm}

The method \textsc{MaintainContact}$(pState,\mathbf{q}^0,k)$ performs inverse kinematics to reach the previous contact position for the Limb.
If it succeeds, the new limb configuration is assigned to $k$. If it fails, a random collision free configuration is assigned to $k$.

The method \textsc{IsInStaticEquilibrium} returns whether a given state is in static equilibrium.

The pseudo code for the method \textsc{IntermediateContactState} is given by Algorithm~\ref{alg:repo}.


\textsc{GenerateContact}$(\mathbf{q}^0,k)$ is a call to the contact generator presented in the following Section~\ref{sec:single_contact}.
 It generates a contact configuration in static equilibrium, and assigns the corresponding configuration to $k$.
If it fails, $k$ remains unchanged if it is collision free, otherwise it is assigned a random collision free configuration.



\begin{algorithm}[!tbp]
\caption{Adds or repositions a contact for one limb} \label{interpolate}
	\begin{algorithmic}[1]
	\Function{IntermediateContactState}{$state$}
		\State $i=0$
		\While {$i<length(states.freeLimbs)$}
			\State Limb $k = pop(states.freeLimbs)$
			\If {\textsc{GenerateContact}$(state.q0,k)$}	
				\State $push(newState.contactLimbs,k)$			
				\State \textbf{return}
			\Else
				\State $i+=1$
				\State $push(states.freeLimbs,k)$		
			\EndIf
		\EndWhile
		\State $i=0$
		\While {$i<length(states.contactLimbs)$}
			\State Limb $k = pop(states.contactLimbs)$
			\State Limb $copy = k$
			\State $i+=1$
			\If {\textsc{GenerateContact}$(state.q0,k)$}	
				\State $push(newState.contactLimbs,k)$			
				\State \textbf{return}
			\Else
				\State $push(newState.contactLimbs,copy)$	
			\EndIf
		\EndWhile
		/*Fails if impossible to relocate any effector*/
		\State \textbf{return} $FAILURE$
	\EndFunction
\end{algorithmic}
\label{alg:repo}
\end{algorithm}

%~ \section{Derivation of the manipulability ellipsoid}
%~ \label{app:manipulability}
%~ 
%~ Again, we assume that $\mathbf{J}$ is full rank. We discard the $k$ indices, and write the pseudo-inverse of $\mathbf{J}$ as $\mathbf{J}^{\dagger}$.
%~ \begin{eqnarray*}
%~ \mathbf{\dot{p}} & =  & \mathbf{J} \dot{\mathbf{q}} \\ 
%~ \mathbf{\dot{q}} & =  & \mathbf{J}^{\dagger} \dot{\mathbf{p}} \\ 
%~ \mathbf{\dot{q}}^T & =  & \dot{\mathbf{p}}^T \mathbf{J}^{\dagger T} \\ 
%~ \mathbf{\dot{q}}^T\mathbf{\dot{q}} & =  & \dot{\mathbf{p}}^T \mathbf{J}^{\dagger T} \mathbf{J}^{\dagger} \dot{\mathbf{p}}\\ 
%~ \end{eqnarray*}
%~ 
%~ Then, the equality $\mathbf{J}^{\dagger T} \mathbf{J}^{\dagger} = (\mathbf{J}\mathbf{J}^T)^{-1}$ follows from the SVD decomposition of each term
%~ ~\citep{ben2003generalized}.
