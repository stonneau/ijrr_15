% !TEX root =  ../main_tro.tex
\subsubsection{Pseudo-code of the Algorithm}
\label{app:contact}


%~ First, we define an abstract structure State,
%~ that describes a contact configuration.
%~ The use of queues allows a FIFO approach regarding the order 
%~ in which contacts are tested: we try to replace older contacts first when necessary.
%~ Thus the algorithm is deterministic even though it can handle acyclic motions. \\
%~ 
%~ \begin{lstlisting}]
%~ Struct Limb
%~ {
    %~ // Limb Configuration
    %~ Configuration qk;
    %~ // Effector position in
    %~ // world coordinates
    %~ vector6 pk;
%~ };
%~ 
%~ Struct State
%~ {
    %~ // root location
    %~ Configuration q0;
    %~ // List of limbs not in contact
    %~ queue<Limb> freeLimbs;
    %~ // List of limbs in contact
    %~ queue<Limb> contactLimbs;
%~ };
%~ \end{lstlisting}

From the start configuration, given as an input by the user,
we create the initial state $s0$. A state is described by a whole-body configuration, as well as the list of currently active contacts and their associated 6D positions.
Algorithm~\ref{alg:interpolate}  is then called with $s0$, as well as the discretized path 
$\mathbf{Q}^0$, as input parameters.

\begin{algorithm}[!tbp]
\caption{Discretization of a path} \label{interpolate}
	\begin{algorithmic}[1]
	%~ \Function{GenerateConfiguration}{}
	\Function{Interpolate}{$s0$,$\mathbf{Q}^0$, $MAX\_TRIES$}
		\State $states \gets (s0)$ \Comment{List of states initialized with $s0$}
		\State $nb\_fail \gets 0$ 
		\State $i \gets 1;$ \Comment{Current index in the list}
		\While {$i < Length(\mathbf{Q}^0)$}
			\State $pState \gets LastElement(states)$
			\State $s \gets$ \textsc{GenFullBody}$(pState, Element(\mathbf{Q}^0,i))$
			\If {$s \not= 0 $}
				\State $nb\_fail \gets 0$
				\State $i \gets i+1$
				%~ \State \textbf{return} $\mathbf{q}^{0}$
			\Else
				\State $nb\_fail \gets nb\_fail + 1$
				%~ \If {$nb\_fail == MAX\_TRIES$}
					%~ \State \textbf{return} $FAILURE$
				%~ \EndIf				
				\State $s \gets $\textsc{IntermediateContactState}$(pState)$
				\If {$s == 0 \lor nb\_fail == MAX\_TRIES$}
					\State \textbf{return} $FAILURE$
				\EndIf		
			\EndIf
			\State \textsc{PushBack}$(states, s)$
		\EndWhile
		\State \textbf{return} $states$
	\EndFunction
\end{algorithmic}
\label{alg:interpolate}
\end{algorithm}

At each step, \textsc{GenFullBody} (Algorithm~\ref{alg:pi}) is called with the previous state as a parameter, as well
as a new root configuration. \textsc{GenFullBody} returns a new contact configuration, if it succeeded
in computing a configuration with only one contact switch occurring.
Otherwise, the method \textsc{IntermediateContactState} (Algorithm~\ref{alg:repo}) is called.
It repositions one end effector (either a free limb, or the oldest active contact) towards a new contact position if possible.
This repositioning allows to increase the odds that the contact can be maintained at the next step.
The method \textit{Length} returns the length of a list, \textit{LastElement} returns the last element
of a list, \textit{Element} returns the element contained by a list at a given index, and \textsc{PushBack} inserts an element at the end of a list.
%~ Algorithm~\ref{alg:pi} gives the pseudo code for \textsc{GenFullBody}.

\begin{algorithm}[!tbp]
\caption{Full body contact generation method} \label{interpolate}
	\begin{algorithmic}[1]
	%~ \Function{GenerateConfiguration}{}
	\Function{\textsc{GenFullBody}}{$pState$,$\mathbf{q}^0$}
		\State $newState \gets \textsc{CreateState}(\mathbf{q}^0,$ 
        \State $\quad \quad \quad \quad  \quad  \quad  \quad  \quad  \quad \quad  \quad ContactLimbs(pState))$
		%~ \State /*First try to maintain previous contacts*/
		\State $nConBroken \gets 0$
		\For {\textbf{each} $k$ in $ContactLimbs(pState)$}
			\If {$\neg$\textsc{MaintainContact}$(pState,\mathbf{q}^0,k)$}
				\State $nConBroken \gets nConBroken +1$
				\If {$nConBroken > 1$}				
					\State \textbf{return} $0$
				\EndIf				
				\State \textsc{MarkFree}$(newState,k)$
			\Else 					
				\State \textsc{MarkContact}$(newState,k)$
			\EndIf
		\EndFor
		\For {\textbf{each} $k$ in $FreeLimbs(newState)$}
			\If {\textsc{GenerateContact}$(newState,k)$}	
				\State \textsc{MarkContact}$(newState,k)$
				\State \textbf{return} $newState$
			\EndIf
		\EndFor
		\If {\textsc{IsInStaticEquilibrium}$(newState)$}
			\State \textbf{return} $newState$
		\Else
			\State \textbf{return} $0$
		\EndIf
	\EndFunction
\end{algorithmic}
\label{alg:pi}
\end{algorithm}

The procedure \textsc{MaintainContact}$(pState,\mathbf{q}^0,k)$ performs inverse kinematics to reach the previous contact position for the limb.
If it succeeds, the new limb configuration is assigned to $k$. If it fails, a random collision free configuration is assigned to $k$.
The method \textsc{IsInStaticEquilibrium} returns whether a given state is in static equilibrium. \textsc{CreateState} creates a new state, given
a root configuration and the list of active contacts.
$ContactLimbs$ (respectively $FreeLimbs$) returns the list of limbs that are in contact (respectively \textit{not} in contact).  \textsc{MarkContact} (respectively \textsc{MarkFree})  marks a limb as in contact (respectively \textit{not} in contact). These methods follow a FIFO approach: the first limb chronologically marked as in contact (respectively not in contact) is returned first by $ContactLimbs$ (respectively $FreeLimbs$). This allows the algorithm to be deterministic even though it can handle acyclic motions.
%~ $add\_contact\_limb(newState,k)$ marks a limb as in contact at a given state.

%~ The pseudo code for the method \textsc{IntermediateContactState} is given by Algorithm~\ref{alg:repo}.


\textsc{GenerateContact}$(state,k)$ is a call to the contact generator presented in the following Section~\ref{sec:single_contact}.
It generates a contact configuration in static equilibrium, and assigns the corresponding configuration of the limb $k$ to the state configuration.
If it fails, $k$ remains unchanged if it is collision free, otherwise it is assigned a random collision free configuration.



\begin{algorithm}[!tbp]
\caption{Adds or repositions a contact for one limb} \label{interpolate}
	\begin{algorithmic}[1]
	\Function{IntermediateContactState}{$state$}        
        \State $newState \gets state$
		\For {\textbf{each} $k$ in $FreeLimbs(newState)$}
			\If {\textsc{GenerateContact}$(newState,k)$}	
				\State \textsc{MarkContact}$(newState,k)$			
				\State \textbf{return} $newState$
			%~ \Else
				%~ \State \textsc{MarkFree}$(newState,k)$	\comment{Mark }
				%~ \State $push(states.freeLimbs,k)$		
			\EndIf
		\EndFor
		\For {\textbf{each} $k$ in $ContactLimbs(newState)$}
			\If {\textsc{GenerateContact}$(newState,k)$}	
				\State /*Account for repositioning in FIFO queue*/		
				\State \textsc{MarkContact}$(newState,k)$
				\State \textbf{return} $newState$
			%~ \Else
				%~ \State \textsc{MarkFree}$(newState,k)$	\comment{Mark }
				%~ \State $push(states.freeLimbs,k)$		
			\EndIf
		\EndFor
        \State
		/*Fails if impossible to relocate any effector*/
		\State \textbf{return} $0$
        %~ 
        %~ 
		%~ \State $i \gets 0$
		%~ \While {$i<length(states.freeLimbs)$}
			%~ \State Limb $k = pop(states.freeLimbs)$
			%~ \If {\textsc{GenerateContact}$(state,k)$}	
				%~ \State $push(newState.contactLimbs,k)$			
				%~ \State \textbf{return}
			%~ \Else
				%~ \State $i+=1$
				%~ \State $push(states.freeLimbs,k)$		
			%~ \EndIf
		%~ \EndWhile
		%~ \State $i=0$
		%~ \While {$i<length(states.contactLimbs)$}
			%~ \State Limb $k = pop(states.contactLimbs)$
			%~ \State Limb $copy = k$
			%~ \State $i+=1$
			%~ \If {\textsc{GenerateContact}$(state.q0,k)$}	
				%~ \State $push(newState.contactLimbs,k)$			
				%~ \State \textbf{return}
			%~ \Else
				%~ \State $push(newState.contactLimbs,copy)$	
			%~ \EndIf
		%~ \EndWhile
		%~ /*Fails if impossible to relocate any effector*/
		%~ \State \textbf{return} $FAILURE$
	\EndFunction
\end{algorithmic}
\label{alg:repo}
\end{algorithm}

%~ \section{Derivation of the manipulability ellipsoid}
%~ \label{app:manipulability}
%~ 
%~ Again, we assume that $\mathbf{J}$ is full rank. We discard the $k$ indices, and write the pseudo-inverse of $\mathbf{J}$ as $\mathbf{J}^{\dagger}$.
%~ \begin{eqnarray*}
%~ \mathbf{\dot{p}} & =  & \mathbf{J} \dot{\mathbf{q}} \\ 
%~ \mathbf{\dot{q}} & =  & \mathbf{J}^{\dagger} \dot{\mathbf{p}} \\ 
%~ \mathbf{\dot{q}}^T & =  & \dot{\mathbf{p}}^T \mathbf{J}^{\dagger T} \\ 
%~ \mathbf{\dot{q}}^T\mathbf{\dot{q}} & =  & \dot{\mathbf{p}}^T \mathbf{J}^{\dagger T} \mathbf{J}^{\dagger} \dot{\mathbf{p}}\\ 
%~ \end{eqnarray*}
%~ 
%~ Then, the equality $\mathbf{J}^{\dagger T} \mathbf{J}^{\dagger} = (\mathbf{J}\mathbf{J}^T)^{-1}$ follows from the SVD decomposition of each term
%~ ~\citep{ben2003generalized}.
